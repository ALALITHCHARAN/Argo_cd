Here’s a **complete step-by-step guide** to set up **Argo CD on an existing Kubernetes cluster in an offline VM**, using **Ingress** for access. This is tailored for air-gapped environments.

---

## ✅ Overview

* ✅ Prepare all Argo CD container images and manifests **online**
* ✅ Transfer them to the **offline VM**
* ✅ Load images, apply manifests
* ✅ Expose Argo CD via **Ingress**
* ✅ Login and use Argo CD

---

## 🧰 Prerequisites

* An **existing Kubernetes cluster** running on the offline VM
* **Ingress controller** (e.g., NGINX) already set up and working
* **kubectl** access to the cluster
* **Docker** installed (to load images)
* Hostname or IP configured for Ingress (e.g., `argocd.local`)

---

## 🌐 STEP 1: Prepare Resources on Online Machine

### 1.1 Download Argo CD Manifests

```bash
wget https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml -O argocd-install.yaml
```

### 1.2 Download All Required Argo CD Images

```sh
argocd$ grep image argocd-install.yaml | awk '{print $2}' | sort -u

ghcr.io/dexidp/dex:v2.41.1
quay.io/argoproj/argocd:v3.0.6
docker.io/library/redis:7.2.7-alpine
```

```bash
# Replace with actual version used in manifest (e.g., v2.11.0)
docker pull quay.io/argoproj/argocd:v2.11.0
docker pull quay.io/argoproj/argocd-dex:v2.11.0
docker pull quay.io/argoproj/argocd-redis:v2.11.0
docker pull quay.io/argoproj/argocd-applicationset:v2.11.0
docker pull quay.io/argoproj/argocd-notifications:v2.11.0
```

### 1.3 Save Images to `.tar` Files

```bash
mkdir argocd-images && cd argocd-images

docker save quay.io/argoproj/argocd:v2.11.0 -o argocd.tar
docker save quay.io/argoproj/argocd-dex:v2.11.0 -o dex.tar
docker save quay.io/argoproj/argocd-redis:v2.11.0 -o redis.tar
docker save quay.io/argoproj/argocd-applicationset:v2.11.0 -o applicationset.tar
docker save quay.io/argoproj/argocd-notifications:v2.11.0 -o notifications.tar
```

---

## 🔁 STEP 2: Transfer Files to Offline VM

Use `scp`, USB, or any method to copy the following to the offline VM:

* `argocd-install.yaml`
* All `.tar` image files

Example:

```bash
scp *.tar user@offline-vm:/home/user/argocd/
scp argocd-install.yaml user@offline-vm:/home/user/argocd/
```

---

## 💾 STEP 3: Load Images on Offline VM

On the offline VM:

```bash
cd /home/user/argocd/

docker load -i argocd.tar
docker load -i dex.tar
docker load -i redis.tar
docker load -i applicationset.tar
docker load -i notifications.tar
```

> 🧠 **Optional**: If your cluster uses containerd or cri-o, push to a private registry or load using `ctr`.

---

## 🚀 STEP 4: Install Argo CD on Kubernetes

```bash
kubectl create namespace argocd
kubectl apply -n argocd -f argocd-install.yaml
```

> ⚠️ **Note:** If the pods fail due to image pull errors, edit `argocd-install.yaml` and replace the `image:` fields with locally loaded image tags (if needed, tag as local or load into local registry).

---

## 🌐 STEP 5: Expose Argo CD via Ingress

### 5.1 Patch the Service to ClusterIP

```bash
kubectl -n argocd patch svc argocd-server -p '{"spec": {"type": "ClusterIP"}}'
```

### 5.2 Create an Ingress Resource

Create `argocd-ingress.yaml`:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-server-ingress
  namespace: argocd
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  rules:
  - host: argocd.local    # 🔁 change as needed
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: argocd-server
            port:
              number: 443
```

Apply it:

```bash
kubectl apply -f argocd-ingress.yaml
```

---

## 📌 STEP 6: Map Hostname for Access

### Option 1: On your machine

Edit `/etc/hosts`:

```
<your-offline-vm-ingress-ip>    argocd.local
```

### Option 2: Use IP-based access with `nip.io`

Replace the Ingress host with:

```yaml
host: <vm-ip>.nip.io
```

---

## 🔐 STEP 7: Get Argo CD Admin Password

```bash
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d && echo
```

---

## 🌐 STEP 8: Access Argo CD Web UI

Go to:

```
https://argocd.local
```

* **Username**: `admin`
* **Password**: (from previous command)

Ignore self-signed cert warning if you don’t have TLS setup.

---

## ✅ OPTIONAL: TLS with Self-Signed Cert

Create and apply TLS secret:

```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -out argocd.crt -keyout argocd.key -subj "/CN=argocd.local"

kubectl create secret tls argocd-tls --cert=argocd.crt --key=argocd.key -n argocd
```

Update `argocd-ingress.yaml` with:

```yaml
tls:
- hosts:
  - argocd.local
  secretName: argocd-tls
```

Reapply the manifest:

```bash
kubectl apply -f argocd-ingress.yaml
```

---

## 🎯 (Optional) Install CLI for Admin Use

On the offline VM (pre-download online if needed):

```bash
# Copy argocd binary to offline VM
chmod +x argocd
sudo mv argocd /usr/local/bin/
```

Then login:

```bash
argocd login argocd.local --username admin --password <password> --insecure
```

---

## 🧩 (Optional) Create a Sample Argo CD Application

```bash
argocd app create guestbook \
  --repo https://github.com/argoproj/argocd-example-apps.git \
  --path guestbook \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace default

argocd app sync guestbook
```

---

## 🎉 Done!

Your offline Argo CD is fully operational!

Let me know if you want:

* A local Docker registry setup
* TLS using cert-manager
* Private Git repository integration
* Argo CD HA setup

I can give tailored steps.
